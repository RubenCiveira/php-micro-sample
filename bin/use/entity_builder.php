<?php

use Civi\Repomanager\Shared\Infrastructure\Store\Service\ExtractDirectives;
use GraphQL\Type\Definition\EnumType;
use GraphQL\Type\Definition\InputObjectType;
use GraphQL\Type\Definition\NamedType;
use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ObjectType;
use PhpParser\ParserFactory;
use PhpParser\Node;
use PhpParser\NodeTraverser;
use PhpParser\BuilderFactory;
use PhpParser\PrettyPrinter\Standard as PrettyPrinter;
use PhpParser\Node\Stmt\Property;
use PhpParser\Node\Stmt\ClassMethod;

function generateEntityFromType(InputObjectType|ObjectType $type, string $fqn, string $filePath): void
{
    $fqn = str_replace('.', '\\', $fqn);
    $parser = (new ParserFactory())->createForNewestSupportedVersion();
    $pretty = new PrettyPrinter();
    $factory = new BuilderFactory();

    if (!is_dir(dirname($filePath))) {
        mkdir(dirname($filePath), 0755, true);
    }

    $className = $type->name();
    $namespace = implode('\\', array_slice(explode('\\', $fqn), 0, -1));

    // ðŸ” Mapeamos los campos SDL a propiedades PHP
    $newProps = [];
    foreach ($type->getFields() as $field) {
        $propType = mapGqlTypeToPhp($field);
        $newProps[$field->name] = $factory
            ->property($field->name)
            ->makePublic()
            ->setDefault(null)
            ->setType($propType)
            ->getNode();
    }

    if (!file_exists($filePath)) {
        // ðŸš§ Si no existe el fichero, generarlo desde cero
        $class = $factory->class($className)->addStmts(array_values($newProps))->getNode();
        $stmts = [new Node\Stmt\Namespace_(new Node\Name($namespace), [$class])];
        file_put_contents($filePath, $pretty->prettyPrintFile($stmts));
        echo "âœ… Generado $filePath desde cero\n";
        return;
    }

    // ðŸ“¥ Leer y parsear cÃ³digo existente
    $code = file_get_contents($filePath);
    $ast = $parser->parse($code);

    // ðŸ” Buscar clase, propiedades y mÃ©todo from()
    $existingProps = [];
    $existingMethods = [];
    $fromMethodRef = null;

    $traverser = new NodeTraverser();
    $traverser->addVisitor(new class ($newProps, $existingProps, $existingMethods, $fromMethodRef) extends \PhpParser\NodeVisitorAbstract {
        public function __construct(
            private array &$newProps,
            private array &$foundProps,
            private array &$foundMethods,
            private ?Node\Stmt\ClassMethod &$fromMethod
        ) {
        }

        public function enterNode(Node $node)
        {
            if ($node instanceof Node\Stmt\Property) {
                foreach ($node->props as $prop) {
                    $this->foundProps[] = $prop->name->name;
                }
            }
            if ($node instanceof Node\Stmt\ClassMethod) {
                $this->foundMethods[] = $node->name->name;
            }
            if ($node instanceof Node\Stmt\ClassMethod && $node->name->name === 'from') {
                $doc = $node->getDocComment()?->getText();
                if ($doc && str_contains($doc, '@autogenerated')) {
                    $this->fromMethod = $node;
                }
            }
        }
    });

    $traverser->traverse($ast);

    // ðŸ’¡ Buscar propiedades que faltan
    $missing = array_diff_key($newProps, array_flip($existingProps));

    if ($missing) {
        $traverserAdd = new NodeTraverser();
        $traverserAdd->addVisitor(new class ($missing) extends \PhpParser\NodeVisitorAbstract {
            public function __construct(private array $propsToAdd)
            {
            }

            public function enterNode(Node $node)
            {
                if ($node instanceof Node\Stmt\Class_) {
                    foreach ($this->propsToAdd as $prop) {
                        $node->stmts[] = $prop;
                    }
                }
            }
        });
        $ast = $traverserAdd->traverse($ast);
    }

    // ðŸ› ï¸ Regenerar mÃ©todo from() si tiene @autogenerated
    if ($fromMethodRef || !in_array('from', $existingMethods)) {
        $fromMethodBody = [];
        $fromMethodBody[] = new Node\Stmt\Expression(
            new Node\Expr\Assign(new Node\Expr\Variable('self'), new Node\Expr\New_(new Node\Name('self')))
        );

        foreach ($type->getFields() as $field) {
            $fromMethodBody[] = new Node\Stmt\Expression(
                new Node\Expr\Assign(
                    new Node\Expr\PropertyFetch(new Node\Expr\Variable('self'), $field->name),
                    new Node\Expr\BinaryOp\Coalesce(
                        new Node\Expr\ArrayDimFetch(new Node\Expr\Variable('data'), new Node\Scalar\String_($field->name)),
                        new Node\Expr\ConstFetch(new Node\Name('null'))
                    )
                )
            );
        }

        $fromMethodBody[] = new Node\Stmt\Return_(new Node\Expr\Variable('self'));

        $fromMethodNode = new Node\Stmt\ClassMethod('from', [
            'flags' => Node\Stmt\Class_::MODIFIER_PUBLIC | Node\Stmt\Class_::MODIFIER_STATIC,
            'params' => [
                new Node\Param(
                    var: new Node\Expr\Variable('data'),
                    type: new Node\Identifier('array')
                )
            ],
            'returnType' => new Node\Name('self'),
            'stmts' => $fromMethodBody
        ], [
            'comments' => [
                new \PhpParser\Comment\Doc("/**\n * @autogenerated\n */")
            ]
        ]);

        if ($fromMethodRef) {
            // ðŸ›  Reemplazar el contenido del mÃ©todo existente
            $fromMethodRef->stmts = $fromMethodBody;
        } else {
            // âž• AÃ±adir el mÃ©todo completo a la clase
            foreach ($ast as $node) {
                if ($node instanceof PhpParser\Node\Stmt\Namespace_) {
                    foreach ($node->stmts as $stmt) {
                        if ($stmt instanceof PhpParser\Node\Stmt\Class_) {
                            $stmt->stmts[] = $fromMethodNode;
                        }
                    }
                }
            }
        }
    }

    // ðŸ’¾ Guardar el nuevo archivo
    foreach ($ast as $node) {
        if ($node instanceof PhpParser\Node\Stmt\Namespace_) {
            foreach ($node->stmts as $stmt) {
                if ($stmt instanceof PhpParser\Node\Stmt\Class_) {
                    reorderClassStatements($stmt);
                }
            }
        }
    }
    $newCode = $pretty->prettyPrintFile($ast);
    file_put_contents($filePath, $newCode);
    echo "âœ… Actualizado $filePath\n";
}

function mapGqlTypeToPhp($field): string
{
    $type = $field->getType();
    while ($type instanceof NonNull) {
        $type = $type->getWrappedType();
    }
    $directives = ExtractDirectives::fromNode($field);
    $as = $directives['format']['type'] ?? '';
    if( $as == 'date' || $as == 'date-time') {
        return '?\DateTimeInterface';
    } else if ($type instanceof EnumType) {
        return '?string';
    } else if ($type instanceof NamedType) {
        return match ($type->name()) {
            'ID', 'String' => '?string',
            'Int', 'Float' => '?int',
            'Boolean' => '?bool',
            'DateTime' => '?\DateTimeInterface',
            default => 'mixed'
        };
    }
    return 'mixed';
}

function reorderClassStatements(\PhpParser\Node\Stmt\Class_ $class): void
{
    $properties = [];
    $methods = [];
    $others = [];
    foreach ($class->stmts as $stmt) {
        if ($stmt instanceof Property) {
            $properties[] = $stmt;
        } elseif ($stmt instanceof ClassMethod) {
            $methods[] = $stmt;
        } else {
            $others[] = $stmt;
        }
    }
    // Ordenar por nombre de propiedad (puede haber varias por property)
    usort($properties, function (Property $a, Property $b) {
        return strcmp($a->props[0]->name->toString(), $b->props[0]->name->toString());
    });

    usort($methods, function (ClassMethod $a, ClassMethod $b) {
        return strcmp($a->name->toString(), $b->name->toString());
    });
    $class->stmts = array_merge($properties, $others, $methods);
}
