<?php

use GraphQL\Type\Definition\ObjectType;
use PhpParser\BuilderFactory;
use PhpParser\ParserFactory;
use PhpParser\PrettyPrinter\Standard as PrettyPrinter;
use PhpParser\Node;

function generateEntityViewFromType(ObjectType $type, string $group, string $fqn, string $filePath): void
{
 
    $fqn = str_replace('.', '\\', $fqn);
    $parser = (new ParserFactory())->createForNewestSupportedVersion();
    $pretty = new PrettyPrinter();
    $factory = new BuilderFactory();

    if (!is_dir(dirname($filePath))) {
        mkdir(dirname($filePath), 0755, true);
    }

    $className = $type->name() . 'ViewMetadata';
    $entityClass = implode('\\', array_slice(explode('\\', $fqn), 0));
    $entityShort = array_slice(explode('\\', $fqn), -1)[0];
    $namespace = implode('\\', array_slice(explode('\\', $fqn), 0, -1)) . '\\View';

    // Crear método build()
    $buildMethod = new Node\Stmt\ClassMethod('build', [
        'flags' => Node\Stmt\Class_::MODIFIER_PUBLIC,
        'stmts' => [
            new Node\Stmt\Return_(
                new Node\Expr\MethodCall(
                    new Node\Expr\PropertyFetch(new Node\Expr\Variable('this'), 'repository'),
                    'build'
                )
            )
        ],
        'returnType' => new Node\Name('ViewMetadata')
    ], [
        'comments' => [new \PhpParser\Comment\Doc("/**\n * @autogenerated\n */")]
    ]);

    // Crear constructor
    $constructMethod = new Node\Stmt\ClassMethod('__construct', [
        'flags' => Node\Stmt\Class_::MODIFIER_PUBLIC,
        'params' => [
            new Node\Param(
                var: new Node\Expr\Variable('repository'),
                type: new Node\Name('Repository')
            )
        ],
        'stmts' => [
            new Node\Stmt\Expression(
                new Node\Expr\Assign(
                    new Node\Expr\PropertyFetch(new Node\Expr\Variable('this'), 'repository'),
                    new Node\Expr\MethodCall(
                        new Node\Expr\Variable('repository'),
                        'formMetadata',
                        [
                            new Node\Arg(new Node\Scalar\String_($group)),
                            new Node\Arg(new Node\Expr\ClassConstFetch(new Node\Name($entityShort), 'class'))
                        ]
                    )
                )
            )
        ]
    ], [
        'comments' => [new \PhpParser\Comment\Doc("/**\n * @autogenerated\n */")]
    ]);

    $repositoryProperty = new Node\Stmt\Property(
        flags: Node\Stmt\Class_::MODIFIER_PRIVATE | Node\Stmt\Class_::MODIFIER_READONLY,
        props: [
            new Node\Stmt\PropertyProperty('repository')
        ],
        attrGroups: [],
        type: new Node\Name('EntityViewMetadata')
    );

    $uses = [
        new Node\Stmt\Use_([
            new Node\Stmt\UseUse(new Node\Name($fqn)),
        ]),
        new Node\Stmt\Use_([
            new Node\Stmt\UseUse(new Node\Name('Civi\Repomanager\Shared\Infrastructure\View\ViewMetadata')),
        ]),
        new Node\Stmt\Use_([
            new Node\Stmt\UseUse(new Node\Name('Civi\Repomanager\Shared\Infrastructure\Store\EntityViewMetadata')),
        ]),
        new Node\Stmt\Use_([
            new Node\Stmt\UseUse(new Node\Name('Civi\Repomanager\Shared\Infrastructure\Store\Repository')),
        ])
    ];

    // Si el fichero no existe, generar clase completa
    if (!file_exists($filePath)) {
        $class = new Node\Stmt\Class_($className, [
            'stmts' => [
                $repositoryProperty,
                $constructMethod,
                $buildMethod,
            ]
        ]);

        $namespaceStmt = new Node\Stmt\Namespace_(new Node\Name($namespace), array_merge($uses, [$class]));
        $code = $pretty->prettyPrintFile([$namespaceStmt]);
        file_put_contents($filePath, $code);
        echo "✅ Generado nuevo adaptador en $filePath\n";
        return;
    }

    // Si existe, cargar AST, conservar lo manual y actualizar solo los métodos @autogenerated
    $code = file_get_contents($filePath);
    $ast = $parser->parse($code);

    $classNode = null;
    foreach ($ast as $node) {
        if ($node instanceof Node\Stmt\Namespace_) {
            foreach ($node->stmts as $stmt) {
                if ($stmt instanceof Node\Stmt\Class_ && $stmt->name->toString() === $className) {
                    $classNode = $stmt;
                    break 2;
                }
            }
        }
    }

    if (!$classNode) {
        throw new \RuntimeException("No se encontró la clase $className en $filePath");
    }

    // Reemplazar métodos @autogenerated
    foreach ($classNode->stmts as $i => $stmt) {
        if ($stmt instanceof Node\Stmt\ClassMethod) {
            $doc = $stmt->getDocComment()?->getText();
            if ($doc && str_contains($doc, '@autogenerated')) {
                if ($stmt->name->name === 'build') {
                    $classNode->stmts[$i] = $buildMethod;
                } elseif ($stmt->name->name === '__construct') {
                    $classNode->stmts[$i] = $constructMethod;
                }
            }
        }
    }

    // Asegurar que la propiedad exista (si no estaba aún)
    $hasRepoProp = false;
    foreach ($classNode->stmts as $stmt) {
        if ($stmt instanceof Node\Stmt\Property && $stmt->props[0]->name->toString() === 'repository') {
            $hasRepoProp = true;
            break;
        }
    }
    if (!$hasRepoProp) {
        array_unshift($classNode->stmts, $repositoryProperty);
    }

    $code = $pretty->prettyPrintFile($ast);
    file_put_contents($filePath, $code);
    echo "✅ Actualizado $filePath (solo métodos @autogenerated)\n";
}


