<?php

use Civi\Store\Service\ExtractMutation;
use GraphQL\Type\Definition\ObjectType;
use PhpParser\BuilderFactory;
use PhpParser\Node\Scalar\String_;
use PhpParser\ParserFactory;
use PhpParser\PrettyPrinter\Standard as PrettyPrinter;
use PhpParser\Node;

function generateEntityRepositoryFromType(ObjectType $type, string $group, string $fqn, string $filePath): void
{
    $fqn = str_replace('.', '\\', $fqn);
    $parser = (new ParserFactory())->createForNewestSupportedVersion();
    $pretty = new PrettyPrinter();
    $factory = new BuilderFactory();

    if (!is_dir(dirname($filePath))) {
        mkdir(dirname($filePath), 0755, true);
    }

    $baseName = $type->name();
    $className = $baseName . 'Gateway';
    $entityClass = $fqn;
    $entityShort = array_slice(explode('\\', $fqn), -1)[0];
    $namespace = implode('\\', array_slice(explode('\\', $fqn), 0, -1)) . '\\Gateway';

    $resourceKey = strtolower($baseName) . 's'; // ej: packages, clientes

    // Usings
    $uses = [
        new Node\Stmt\Use_([
            new Node\Stmt\UseUse(new Node\Name($entityClass)),
        ]),
        new Node\Stmt\Use_([
            new Node\Stmt\UseUse(new Node\Name('Civi\Store\EntityRepository')),
        ]),
        new Node\Stmt\Use_([
            new Node\Stmt\UseUse(new Node\Name('Civi\Store\Repository')),
        ])
    ];

    // Propiedad
    $repositoryProperty = new Node\Stmt\Property(
        flags: Node\Stmt\Class_::MODIFIER_PRIVATE | Node\Stmt\Class_::MODIFIER_READONLY,
        props: [new Node\Stmt\PropertyProperty('repository')],
        attrGroups: [],
        type: new Node\Name('EntityRepository')
    );

    // __construct
    $methods = [];
    $methods['__construct'] = new Node\Stmt\ClassMethod('__construct', [
        'flags' => Node\Stmt\Class_::MODIFIER_PUBLIC,
        'params' => [
            new Node\Param(new Node\Expr\Variable('repository'), type: new Node\Name('Repository'))
        ],
        'stmts' => [
            new Node\Stmt\Expression(
                new Node\Expr\Assign(
                    new Node\Expr\PropertyFetch(new Node\Expr\Variable('this'), 'repository'),
                    new Node\Expr\MethodCall(
                        new Node\Expr\Variable('repository'),
                        'entityRepository',
                        [
                            new Node\Arg(new Node\Scalar\String_($group)),
                            new Node\Arg(new Node\Expr\ClassConstFetch(new Node\Name($entityShort), 'class'))
                        ]
                    )
                )
            )
        ]
    ], [
        'comments' => [new \PhpParser\Comment\Doc("/**\n * @autogenerated\n */")]
    ]);


    $ex = new ExtractMutation();
    $mutations = $ex->fromType($type);
    foreach($mutations as $mutation) {
        $params = [];
        $args = [ new Node\Arg( new String_($mutation['name'])) ];
        if( $mutation['context'] != 'create' ) {
            $params[] = new Node\Param(new Node\Expr\Variable('id'), type: new Node\Identifier('string'));
            $args[] = new Node\Arg(new Node\Expr\Variable('id'));
        }
        if( $mutation['assign'] ) {
            $params[] = new Node\Param(new Node\Expr\Variable('input'), type: new Node\Name($entityShort));
            $args[] = new Node\Arg(new Node\Expr\Variable('input'));
        }
        $use = '';
        switch ($mutation['context']) {
            case 'create':
                $use = 'create';
                break;
            default:
                $use = $mutation['assign'] ? 'modify' : 'change';
                break;
        }

        $methods[$mutation['name'] . $baseName] = new Node\Stmt\ClassMethod($mutation['name'] . $baseName, [
            'flags' => Node\Stmt\Class_::MODIFIER_PUBLIC,
            'params' => $params,
            'stmts' => [
                new Node\Stmt\Expression(
                    new Node\Expr\MethodCall(
                        new Node\Expr\PropertyFetch(new Node\Expr\Variable('this'), 'repository'),
                        $use, $args
                    )
                )
            ]
        ], [
            'comments' => [new \PhpParser\Comment\Doc("/**\n * @autogenerated\n */")]
        ]);
    }

    // listXs
    $methods['list' . $baseName . 's'] = new Node\Stmt\ClassMethod('list' . $baseName . 's', [
        'flags' => Node\Stmt\Class_::MODIFIER_PUBLIC,
        'returnType' => new Node\Identifier('array'),
        'stmts' => [
            new Node\Stmt\Return_(
                new Node\Expr\MethodCall(
                    new Node\Expr\PropertyFetch(new Node\Expr\Variable('this'), 'repository'),
                    'listView',
                    [
                        new Node\Arg(new Node\Expr\Array_([], ['kind' => Node\Expr\Array_::KIND_SHORT])),
                        new Node\Arg(new Node\Expr\Array_([], ['kind' => Node\Expr\Array_::KIND_SHORT]))
                    ]
                )
            )
        ]
    ], [
        'comments' => [new \PhpParser\Comment\Doc("/**\n * @autogenerated\n */")]
    ]);

    // Construcción de clase si no existe
    if (!file_exists($filePath)) {
        $class = new Node\Stmt\Class_($className, [
            'stmts' => array_merge([$repositoryProperty], array_values($methods))
        ]);

        $ns = new Node\Stmt\Namespace_(new Node\Name($namespace), array_merge($uses, [$class]));
        $code = $pretty->prettyPrintFile([$ns]);
        file_put_contents($filePath, $code);
        echo "✅ Generado nuevo repositorio en $filePath\n";
        return;
    }

    // Si el fichero existe, parsear y modificar solo métodos @autogenerated
    $code = file_get_contents($filePath);
    $ast = $parser->parse($code);

    $classNode = null;
    foreach ($ast as $node) {
        if ($node instanceof Node\Stmt\Namespace_) {
            foreach ($node->stmts as $stmt) {
                if ($stmt instanceof Node\Stmt\Class_ && $stmt->name->name === $className) {
                    $classNode = $stmt;
                    break 2;
                }
            }
        }
    }

    if (!$classNode) {
        throw new \RuntimeException("No se encontró la clase $className en $filePath");
    }

    // $replacements = [
    //     '__construct' => $constructMethod,
    //     'create' . $baseName => $createMethod,
    //     'update' . $baseName => $updateMethod,
    //     'remove' . $baseName => $removeMethod,
    //     'list' . $baseName . 's' => $listMethod,
    // ];

    foreach ($classNode->stmts as $i => $stmt) {
        if ($stmt instanceof Node\Stmt\ClassMethod) {
            $doc = $stmt->getDocComment()?->getText();
            if ($doc && str_contains($doc, '@autogenerated')) {
                $methodName = $stmt->name->name;
                if (isset($methods[$methodName])) {
                    $classNode->stmts[$i] = $methods[$methodName];
                }
            }
        }
    }

    // Asegurar que la propiedad exista
    $hasRepoProp = false;
    foreach ($classNode->stmts as $stmt) {
        if ($stmt instanceof Node\Stmt\Property && $stmt->props[0]->name->toString() === 'repository') {
            $hasRepoProp = true;
            break;
        }
    }
    if (!$hasRepoProp) {
        array_unshift($classNode->stmts, $repositoryProperty);
    }

    // Guardar resultado final
    $code = $pretty->prettyPrintFile($ast);
    file_put_contents($filePath, $code);
    echo "✅ Repositorio actualizado en $filePath (sólo métodos @autogenerated)\n";
}
